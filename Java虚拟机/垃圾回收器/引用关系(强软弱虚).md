在JDK1.2之后，Java对引用的概念进行了扩充，将引用分成强引用、软引用、弱引用和虚引用（强软弱虚）。这四种的引用强度依次减弱。除了强引用之外，其他三种引用均可以在java.lang.ref包下。



引用的顶层接口为Reference，该接口还有一个终结器实现类，不过该类是包内可见，平时基本不会用到。



**强引用(StrongReference)**：最传统最基础的引用，指代码中普遍存在的引用赋值。即Object obj = new Object()。无论任何情况下，**只要强引用的关系还存在，垃圾收集器就永远不会回收掉被引用的对象**。



**软引用(SoftReference)**：**在系统将要内存溢出之前，才会把软引用的对象列入回收范围进行二次回收**。如果这次回收还没有足够的内存空间，才会抛OOM(并不是内存不足马上抛OOM)。



**弱引用(WeakReference)**：被弱引用关联的对象只能生存到下一次垃圾回收之前，**当垃圾收集器工作时，无论内存空间是否充足，都会回收掉被弱引用关联的对象**。



**虚引用(PhantomReference)**：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也**无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的，就是能在对象被回收时收到一个系统通知**。



### 强引用—OOM也不回收

在Java程序中，最常见的引用关系便是强引用，也是默认的引用类型。



强引用的对象时可触及的，垃圾收集器永远不会回收掉引用的对象。对于一个普通的对象，如果没有其他的引用关系、超过了引用的作用域、显式的将引用关系赋值为null，那么就可以当做垃圾被收集。



软引用、弱引用、虚引用对应的分别是软可触及、弱可触及、虚可触及，在一定条件下，都可以被回收。而存在强引用的对象是不能被回收的，因此**强引用也是造成内存泄漏的主要原因之一**。



```java
//强引用赋值
String str = new Sting("hello lwx");
```



### 软引用—内存不足即回收



一些有用但非必须的对象，可用软引用进行描述。如用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时就清理掉软引用对象，保证不会耗尽内存。



垃圾回收器在某个时刻，决定回收软可触及的对象的时候，会自动把对应的引用存放到一个引用队列中。通过这个队列，可以跟踪对象的回收情况。



JDK提供了**SoftReference**实现软引用

```java
//将字符串对象包装成软引用
String str = new String("hell lwx");
SoftReference<String> sf = new SoftReference(str);

//销毁强引用
str = null;

//获取软引用的对象
String str1 = sf.get();
```



### 弱引用—发现即回收



弱引用也可以用来描述非必须的对象，被弱引用关联的对象，只能生存到下一次垃圾收集发生前为止。在GC时，不管内存是否充足，都会回收掉弱引用关联的对象。



但是，由于垃圾回收器的线程优先级通常比较低，并不一定能很快的发现弱引用的对象。在这种情况下，弱引用的对象能存在较长的时间。



**弱引用相对于软引用，更容易被GC回收**。



弱引用对应的包装类为**WeakReference**。`WeakHashMap`内部便大量的使用了弱引用。



### 虚引用—对象回收跟踪

虚引用**PhantomReference**也被成为幽灵引用，幻影应用，是所有引用类型中，最弱的一个。。



虚引用也不能单独使用，当试图通过虚引用的get()获取对象时，总是null。被包装为虚引用的对象，**唯一的目的在于可以通过虚引用跟踪垃圾回收的过程**。



虚引用的对象在创建时，还必须提供一个引用队列作为参数，当GC准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通应用程序对象的回收情况。因此，可以将一些资源释放的操作，放在虚引用中执行和记录。



```java
//包装虚引用对象
ReferenceQueue queue = new Reference();
PhantomReference<String> pr = new PhantomReference<>(new String("hello lwx"),queue);

//进行垃圾回收
System.gc();

//从队列中获取被回收的虚引用
String str = queue.remove();
if(str != null){
    System.out.println("虚引用对象被回收");
}
```



### 终结器引用

终结器引用也是Reference的实现类，用来实现对象的finalize()，无需手动编码，其内部配合引用队列使用。

在GC时，终结器引用入队，有Finalizer线程通过终结器引用找到被引用对象，并调用它的finalize()，第二次GC时才会回收被引用对象。

