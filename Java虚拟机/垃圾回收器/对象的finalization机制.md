

这个机制就是`允许开发人员在对象被销毁前，自定义自己的处理逻辑`。该机制体现在finalize()中，在垃圾回收对象前，总会先调用finalize()，该方法允许被子类重写，用于一些资源释放和清理的工作，比如关闭文件、套接字、数据库链接、网络连接等。

类似于tomcat环境的servlet.destory()。



需要强调，**永远不要主动调用对象的finalize()**。原因如下：

- 在虚拟机调用finalize()时，可能导致对象复活。
- finalize()方法的执行时间不确定，由GC线程决定，极端情况下，若没有GC，finalize()不需要执行，也没有执行机会。
- 一个糟糕的finalize()会严重影响GC的性能



可以用finalize()，区分对象三种可能的状态。如果所有的根节点都无法访问到某个对象，说明对象可以被回收，但也并非“非死不可”，而是处于“缓刑”的一个状态。一个无法触及的对象，有可能在某一条件下“复活”自己。那么对他的回收，就是不合理的。

可触及：从根节点开始，可以到达这个对象。

可复活：对象的所有引用被释放，但对象有可能在finalize()中复活。

不可触及：对象finalize()被调用，并且没有复活，进入不可触及状态。不可触及的对象不可能被复活，因为**finalize()只调用一次**。



判断一个对象是否可回收，至少需要经历两次标记的过程：

1、如果对象与GC Roots没有引用链，则进行第一次标记。

2、进行筛选，判断此对象是否有必要执行finalize()方法

①  如果对象没有重写finalize()，或者finalize()已经被JVM调用，则虚拟机视为“没有必要执行”，该对象被判定为不可触及。

②  如果对象重写了finalize()，且还未执行，那么对象会被插入到F-Queue队列中，虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()

③  **finalize()是对象逃脱死亡的最后机会**。稍后会对F-Quene队列中的对象进行第二次标记，如果垃圾对象在finalize()中与引用链上的任何一个对象建立了联系，那么在第二次标记时，垃圾对象会被移除队列。**对象会再次出现没有引用的情况，不过finalize()不会被再次调用，对象会直接变成不可触及的状态**。



`不可触及的对象才能被回收`。