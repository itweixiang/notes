在前面的文章中，并没有一种算法可以完全替代其他算法，他们都具有自己独特的优点和特点。

因此针对对象的一些特性，和内存结构的特性，下面再介绍三种常见的**算法思想**。



#### 分代收集算法




在JVM的内存中，不同对象的生命周期是不一样的，因此，需要**根据不同生命周期的对象采用不同的收集方式**，以提高GC效率。



如HTTP请求中的Session对象、线程、Socket连接等，这类对象存活时间较长；如方法运行时的临时对象、String对象等，存活时间非常短，甚至有些对象只用一次就会被回收。



目前几乎所有的GC，都是采用的分代收集算法进行垃圾回收。



在HotSpot中，各个内存区域采用的算法各不相同：

- 年轻代

年轻代特点：区域相对于老年代较小，**对象生命周期短、存活率低、GC频繁**

这种情况使用**复制算法**回收整理，速度最快。复制算法的效率只和当前存活的对象有关，因此很使用于年轻代的回收。而复制算法内存利用率不高的问题，通过HotSpot的两个Survivor区得到缓解（两个区域内存都不大）



- 老年代

老年代特点：区域较大，**对象生命周期长、存活率高、GC较少**

老年代存在大量存活率高的对象，复制算法明显不合适；**一般是由标记-清除或者标记压缩算法混合实现**。

HotSpot的CMS回收器，便是基于标记清除算法实现，回收效率比较高。对于内存碎片问题，CMS采用标记压缩的Serial Old回收器作为补偿措施，当内存回收不佳时(碎片导致Concurrent Mode Failure)，采用Serial Old执行Full GC以达到对老年代内存的整理。


> 一句话总结：每个对象的存活时间不同，区分处理


#### 增量收集算法




在垃圾回收的过程中，难以避免的会出现Stop The World的状态，在STW下，应用程序的所有线程都会被挂起，暂停一切工作，等待垃圾回收完成。如果STW过长，将会严重影响用户体验和系统稳定。因此，便诞生实时的垃圾收集的**增量收集算法**。



如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，**垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程，依次反复，直到垃圾收集完成**（那要是一直都收集不完呢？？）。



**增量收集算法的基础任然是传统的标记清除和复制算法**，增量收集算法只是通过对线程冲突的妥善处理，允许垃圾收集线程分阶段完成垃圾收集。



缺点：

	在垃圾回收的过程中，间歇性的执行应用程序代码，虽然能减少系统的停顿时间，但是造成GC的效率不高，线程切换和上下文切换，会使垃圾回收的成本上升，降低系统的吞吐量。


> 一句话总结：全量GC的STW太长了，减少每次GC的范围就能减少STW

#### 分区算法




一般来说，在相同条件下，堆空间越大，一次GC所需要的时间就越长，STW停顿也就越长。为了更好的控制GC的停顿时间，可以将一大块内存区域分割成多个小块，根据目标的停顿时间，每次合理的收集若干个小空间的，而不是整个堆。从而控制GC所产生的停顿。


每一个小区间都独立使用，独立回收，好处就是可以控制一次回收多少个小区间(要是对象太大，单个小区间放不下呢？)。


<br/>

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fa8103ffef84218b2b8adbe662fd56d~tplv-k3u1fbpfcp-zoom-1.image)

G1 GC 便实现了该算法的思想
<br/>

分代算法和分区算法的区别：

分代算法将内存按照对象的生命周期分成两个部分，分区算法将整个堆空间划分成连续的小区间。

> 一句话总结：内存区域太大了，把它拆细才能更好的GC
