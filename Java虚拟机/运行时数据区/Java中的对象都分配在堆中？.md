
`Java中的对象可以不分配在堆中，因为还存在栈上分配、同步省略和标量替换`


三种技术都需要使用`逃逸分析`

> 逃逸分析，是一种可以有效减少Java程序中同步负载和堆分配压力的跨函数全局数据流分析算法。

当一个`对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸；如果对象被外部对象引用，则认为发生逃逸`。通过逃逸分析，HotSpot编译器能够分析出一个新对象的使用范围，从而决定是否将这个对象分配到堆上。



未逃逸的实例：

```java
void m(){
    //obj仅在方法中使用，没有发生逃逸
    Object obj = new Object();
}
```

逃逸示例：

```java
Object m(){
	Object obj = new Object();
	return obj;//对象可能被外部对象引用，发生了逃逸
}
```



### 栈上分配

栈上分配所指的栈，是Java方法对应的栈帧。

没有发生逃逸的对象可能被优化分配到栈上，因为随着方法的执行结束，栈空间就被移除。

在JDK6中，HotSpot就已经默认开启了逃逸分析，也可以通过`-XX:+DoEscapeAnalysis`显示开启逃逸分析，`-XX:+PrintEscapeAnalysis`可以查看逃逸分析的筛选结果。

所以在开发中，能使用局部变量的，就不要在方法外定义。





### 同步省略

如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

在动态编译同步代码块时，JIT编译器借助逃逸分析来判断所使用的的锁对象是否只能被一个线程访问而没有发布到其他线程，如果没有，JIT编译器会在编译这个同步块时，取消对这部分代码的同步。这个过程也叫做`锁消除`



示例代码如下：

```java
void m(){
	Object lockObj = new Object();
    synchronized(lockObj){
        //lockObj对象，只能在当前线程访问，所以会被取消同步。
        System.out.print("hello");
    }
}
```

最终代码

```java
void m(){
	Object lockObj = new Object();
    System.out.print("hello");//锁被消除了
}
```






###  标量替换

标量替换也叫`分离对象`

标量是指一个无法再分解的数据，Java中的基本数据类型就是标量，相应的，如Java对象，就是可以再分解的聚合量。在JIT编译时，经过逃逸分析，发现一个对象不会被外界访问，那么就会把这个对象拆分成若干个其中的包含成员变量来代替。



有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(全部)可以不存储在内存，而是存储在CPU的寄存器中。

可以通过`-XX:+EliminateAllocations`开启标量替换(默认开启)，允许将对象打散到栈上。



实例代码如下：

```java
class Location {
    int x;
    int y;
}

void m(){
    Location loc = new Location();
    loc.x = 1;
    loc.y = 2;
    System.out.print("x:"+loc.x+",y:"+loc.y);
}
```

最终代码：

```java
void m(){
    int x = 1;
    int y = 2;
    System.out.print("x:"+x+",y:"+y);
}
```



### 存在的问题

逃逸分析自身也需要一系列复杂的分析，开销较大，无法保证是正优化。如经过分析后，发现所有对象是不逃逸的，那么这个分析过程就浪费了。。所以在HotSpot中并未使用栈上分配，所以可以明确，所有的对象实例都是创建在堆上的。


###  总结

`Java对象实例都是分配在堆上的`
