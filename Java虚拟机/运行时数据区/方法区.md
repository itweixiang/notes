方法区在启动时被创建，是线程共享的区域，可以设置通过参数设置大小。方法区的大小决定了系统可以存放多少个类，如果系统定义了太多的类，导致方法区溢出，则会抛出`OutOfMemoryError:PermGen space`或者`OutOfMemoryError:Metaspace`(加载太多jar，反射太多类)

方法区有一个别名，叫做non-heap(非堆)，是因为在JVM规范中，说明方法区在逻辑上属于堆的一部分。但是一些简单的实现可能不会选择去进行垃圾收集或者内存压缩。



### 方法区的内部结构

方法区用于存储已被JVM加载的类型信息、域信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等。

方法区存放类信息，运行时常量池(字符串常量)

- 类型信息

对每个加载的类型（类class，接口interface，枚举enum、注解annotation），JVM必须在方法区中存储以下的类型信息

1、类型的有效名称(全名 = 包名**.**类名)

2、类型的直接父类的完整有效名

3、类型的修饰符，public、abstract、final

4、类型直接接口的有序列表



- 域(Field，成员变量)信息

JVM必须在方法区中保存类型的所有域的相关信息，以及域的声明顺序

域信息包括：域名称、域类型、域修饰符(public、private、protected、final、volatale、transient的某个子集)



non-final的类变量

静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分

类变量被类的所有实例共享，及时没有实例也可以访问

static final全局常量

被声明为final的类变量的处理方法，在编译的时候就已经被分配了



- 方法信息

JVM必须保存所有方法的以下信息：

方法名称

方法的返回类型

方法的参数数量和类型（按顺序）

方法的修饰符，public，private、protected、static、final、synchronized、native、abstract

方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）

异常表，每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移位置、被捕获的异常类的常量池索引；abstract和native方法除外



- 常量

| -        | 运行时常量池                         | 常量池                                                       |
| :------- | ------------------------------------ | ------------------------------------------------------------ |
| 存放位置 | 方法区                               | 字节码文件                                                   |
| 作用     | 存放编译器生成的各种字面量和符号引用 | 存放字面量和堆类型、域和方法的符号引用，用以减少class文件的大小 |
| 是否唯一 | JVM会为每个类型维护一个常量池        | 每个字节码文件都有一个常量池                                 |

运行时常量池包含多种不同的常量，包括编译器就已经明确的数值字面量，也包括运行期解析后才能获得的方法或者字段引用，此时不再是常量池中的符号地址，而是真实地址，体现了运行时常量池相对于class文件常量池的具有`动态性`

当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大则，则会OOM



### 设置方法区大小

方法区的空间的大小可以是固定的，也可以动态进行调整。

- Java7以前，可以通过`-XX:PermSize`设置永久代初始分配空间，默认20.75M，`-XX:MaxPermSize`设置永久代的最大可分配空间，32位机器默认为64M，64位默认为82M；当方法区的容量超过了-XX:MaxPermSize就会OOM
- Java8，-XX:PermSize改为`-XX:MetaspaceSize`，-XX:MaxPermSize改为`-XX:MaxMetaspaceSize`；两个参数的默认值在不同环境下存在差异，windows环境下，-XX:MetaspaceSize为21M，-XX:MaxMetaspaceSize为-1，即不限制



-XX:MetaspaceSize，对于64位的服务器JVM来说，其默认值为21值，这是一个水位线，当触及这个水位线时，将会触发一次Full GC并卸载没用的类(即这些类的加载器不再存活)，然后这个水位线会被重置。新的水位线取决于GC后释放了多少元空间，如果释放的空间不足，则在不超过-XX:MaxMetaspaceSize的情况下提高水位线，如果释放的空间过多，则适当降低该值。

如果初始化的水位线过低，则会进行多次FullGC进行调高，为了避免Full GC，应该讲-XX:MetaspaceSize设置为一个较高的值。



### 方法区的演进

在Java7以前，习惯把方法区成为`永久代`，在Java8之后，`元空间`取代了永久代



为什么要用元空间取代永久区？主要是为了实现与JRockit的融合，JRockit并没有永久代，而是使用的直接内存。另外，永久代的空间大小很难确定，容易触发Full GC，在某些场景下还会OOM；对永久代进行调优也很困难，。而`元空间并不在虚拟机中，而是使用直接内存`，所以元空间的大小仅受本地内存的限制。



本质上，方法区和永久代并不等价，只有，在JVM规范中并没有对实现方法区做统一要求。如JRockit和J9并没有永久代的概念。

在JVM划分内存成为方法区，容易造成方法区的的OOM，所以在Java8之后，采用了元空间(Metaspace)来代替。元空间本质与永久代类似，都是对方法区的实现，不过`元空间直接使用本地内存，较少会OOM`。



在JDK1.6以前，静态变量存放在永久代中；JDK1.7以后，将字符串常量池、静态变量移除，保存在堆中；JDK1.8之后，去除了永久代，类型信息、字段、方法、常量保存在本地内存的元空间中，但字符串常量池、静态变量仍在堆中。



### 方法区的垃圾回收



JVM规范对方法区的垃圾回收约束比较宽松，JVM可以不实现对方法区的回收，如Java11 ZGC就不支持类卸载。



而且对方法区的GC效果也难令人满意，尤其是类的卸载，条件相当苛刻。不过在低版本的HotSpot虚拟机中，曾出现过若干引方法区未回收而引起的内存泄漏。方法区的垃圾回收是由一个单线程的垃圾收集器执行的，回收的效率非常低下。



方法区的垃圾回收主要回收两部分的内容：`常量池中废弃的常量和不再使用的类型`。



方法区的运行时常量池主要存放两大类常量，即字面量和符号引用。字面量是语言层次的常量概念，如文本字符串，被声明为final的常量值等。符号引用包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。

只要常量池中的常量没有被引用，就可以被回收。

而要判定一个类型是否可以被回收，条件就异常苛刻。首先是该类的所有实例都已被回收；加载该类的加载器已经被回收；该类对应的字节码文件对象没有任何引用。在满足三个条件之后，也仅仅是“被允许”回收，而不是必然被回收。关于是否要对类型进行回收，HotSpot提供了`-Xnocclassgc`参数进行控制。

在大量使用反射、动态代理、CGLib，动态生成的JSP以及OSGi这类频繁自定义类加载器的场景中，通常需要JVM具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

### 为什么字符串常量(StringTable)会被移出方法区？



因为永久代的GC的回收效率低，在Full GC的时候才会触发，而Full GC只有在老年代、永久代不足时才会触发，而我们系统的正常运行中，会有大量的字符串被创建，回收效率低，容易导致永久代空间不足。

JDK1.7之后，将StringTable放到了堆中，堆的回收效率比较方法区高。




### 栈、堆、方法区的交互关系



```java
Object   obj = new Object();
方法区    栈         堆     
```

栈存放对象的引用，堆存放对象的数据，对象的数据中有类型存放于方法区



堆抛的异常，OutOfMemoryError:Java heap space

方法区抛的异常，OutOfMemoryError:Metaspace

栈抛的异常，StackOverflowError


---
- 2020/12/07，修改点为增加方法区GC的描述